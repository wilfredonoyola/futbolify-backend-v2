# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type User {
  userId: ID!
  email: String!
  birthday: DateTime
  phone: String!
  roles: [UserRole!]!
  isOnboardingCompleted: Boolean!
  createdAt: Int!
  updatedAt: Int!
  userName: String!
  name: String
  avatarUrl: String
  googleId: String
  authProvider: String
  activeBrandId: ID
  plan: String
  streamsThisMonth: Int!
  stripeCustomerId: String
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

"""The roles a user can have in the system"""
enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

type SigninOutputDto {
  id: ID!
  access_token: String!
  isOnboardingCompleted: Boolean!
  avatarUrl: String
  name: String
  userName: String
  roles: [UserRole!]!
}

type UserOutputDto {
  id: String!
  email: String!
  userName: String
  name: String
  phone: String
  avatarUrl: String
  roles: [UserRole!]!
}

type GoogleSigninResponse {
  email: String!
  userName: String!
  name: String
  avatarUrl: String
  isProfileCompleted: Boolean!
}

type TimelineEventDto {
  type: String!
  detail: String!
  team: String!
  player: String
  assist: String
  minute: Int!
  isHome: Boolean
  importance: Float
}

type BettingAnalysisDto {
  recommendedBet: String!
  confidence: Int!
  reason: String!
  odds: Float!
  timestamp: String!
}

type PossessionDto {
  home: Int!
  away: Int!
}

type LiveMatchOutputDto {
  id: Int!
  homeTeam: String!
  awayTeam: String!
  minute: Int
  scoreHome: Int!
  scoreAway: Int!
  shots: Int
  shotsOnTarget: Int
  dangerousAttacks: Int
  corners: Int
  pressureScore: Float
  recentActivityScore: Float
  hasRecentActivity: Boolean
  possession: PossessionDto
  xG: Float
  attacks: PossessionDto
  bigChances: PossessionDto
  bettingAnalysis: BettingAnalysisDto
  marketAvailable: Boolean
  lastEventType: String
  isGoodForOver05: Boolean
  isGoodForOver15: Boolean
  isLateMatch: Boolean
  bookmakers: [String!]
  timeline: [TimelineEventDto!]
  state: MatchState
  yellowCards: Int
  redCards: Int
  offsides: Int
  shotsOffTarget: Int
}

enum MatchState {
  NotStarted
  FirstHalf
  HalfTime
  SecondHalf
  Finished
  Normal
  Potential
  ReadyToBet
  NoBet
  NoLateValue
  ModerateLateValue
  HighLateValue
}

type Team {
  id: ID!
  name: String!
  color: TeamColor!
  code: String!
  createdBy: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  matchCount: Int
  mediaCount: Int
  memberCount: Int
}

"""Available team colors"""
enum TeamColor {
  GREEN
  BLUE
  RED
  YELLOW
  PURPLE
  ORANGE
  PINK
  BLACK
  WHITE
}

type TeamMember {
  id: ID!
  teamId: ID!
  userId: ID!
  role: MemberRole!
  joinedAt: DateTime!
}

"""Role of a member in a team"""
enum MemberRole {
  ADMIN
  MEMBER
}

type TeamMatch {
  id: ID!
  teamId: ID!
  date: DateTime!
  opponent: String
  location: String
  createdBy: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  photoCount: Int
  videoCount: Int
  highlightCount: Int
}

type MediaTag {
  id: ID!
  mediaId: ID!
  userId: ID!
  taggedBy: ID!
  createdAt: DateTime!
}

type Media {
  id: ID!
  matchId: ID!
  uploadedBy: ID!
  type: MediaType!
  url: String!
  thumbnailUrl: String
  category: MediaCategory
  isHighlight: Boolean!
  duration: Float
  videoId: String
  storagePath: String
  embedUrl: String
  processingStatus: String
  createdAt: DateTime!
  updatedAt: DateTime!
  tags: [MediaTag!]
}

"""Type of media content"""
enum MediaType {
  PHOTO
  VIDEO
}

"""Category of media content"""
enum MediaCategory {
  GOAL
  PLAY
  FAIL
}

type Notification {
  id: ID!
  userId: ID!
  type: NotificationType!
  title: String!
  message: String!
  imageUrl: String
  actionUrl: String
  isRead: Boolean!
  emailSent: Boolean!
  actorId: ID
  mediaId: ID
  teamId: ID
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Type of notification"""
enum NotificationType {
  TAG
  TEAM_JOIN
  INVITE_ACCEPTED
  NEW_MEDIA
  MENTION
}

type PendingTag {
  id: ID!
  mediaId: ID!
  teamId: ID!
  name: String!
  phone: String
  inviteCode: String!
  status: PendingTagStatus!
  createdBy: ID!
  claimedBy: ID
  claimedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  inviteUrl: String!
  media: Media
  createdByUser: User
}

"""Status of a pending tag invitation"""
enum PendingTagStatus {
  PENDING
  CLAIMED
  CANCELLED
}

type TeamMemberWithUser {
  id: ID!
  teamId: ID!
  userId: ID!
  role: MemberRole!
  joinedAt: DateTime!
  user: User
}

type TeamWithMembers {
  id: ID!
  name: String!
  color: TeamColor!
  code: String!
  createdBy: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  matchCount: Int
  mediaCount: Int
  memberCount: Int
  members: [TeamMemberWithUser!]!
}

type ProfileStats {
  goalCount: Int!
  videoCount: Int!
  photoCount: Int!
}

type ThemeTokens {
  primaryColor: String!
  secondaryColor: String!
  accentColor: String!
  backgroundColor: String!
  textColor: String!
  logo: String!
  fontPrimary: String!
  fontSecondary: String!
  fanPageName: String!
}

type WatermarkConfig {
  style: String!
  position: String!
  customText: String
  showBackground: Boolean!
  backgroundColor: String
  size: String!
}

type ContentPreferences {
  pageType: String
  gender: String
  teamId: String
  leagueId: String
  additionalTeams: [String!]
  contentTypes: [String!]!
  publishLanguage: String!
  sourceLanguages: [String!]!
  notifyBreaking: Boolean!
  notifyMatchday: Boolean!
}

type Brand {
  id: ID!
  userId: ID!
  fanPageId: String!
  fanPageName: String!
  tokens: ThemeTokens!
  watermark: WatermarkConfig!
  contentPreferences: ContentPreferences
  isActive: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Template {
  id: ID!
  userId: ID!
  brandId: ID
  name: String!
  description: String
  category: String!
  thumbnail: String
  width: Int!
  height: Int!
  backgroundColor: String!
  templateData: JSON!
  tags: [String!]
  isPublished: Boolean!
  isPreset: Boolean!
  presetId: String
  type: String!
  postId: ID
  presetCategory: String
  imageAssets: [String!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type ClaimedBy {
  id: ID!
  name: String!
  avatar: String
}

type ContentSuggestion {
  id: ID!
  type: ContentType!
  priority: ContentPriority!
  title: String!
  originalTitle: String
  rewrittenTitle: String
  description: String!
  originalDescription: String
  source: String
  sourceLanguage: String
  sourceUrl: String
  imageUrl: String
  timestamp: DateTime!
  suggestedTemplates: [String!]!
  suggestedCaption: String
  hashtags: [String!]
  viralScore: Int
  relevanceScore: Int
  isRelevant: Boolean
  wasProcessedByAI: Boolean
  status: ContentStatus!
  claimedBy: ClaimedBy
  claimedAt: DateTime
  seenBy: [String!]!
}

enum ContentType {
  BREAKING
  MATCHDAY
  RESULT
  TRANSFER
  INJURY
  STATS
  QUOTE
  MEME
  THROWBACK
  RUMOR
  GENERAL
}

enum ContentPriority {
  URGENT
  HIGH
  NORMAL
  LOW
}

enum ContentStatus {
  AVAILABLE
  CLAIMED
  IN_PROGRESS
  DONE
  DISMISSED
}

type NextMatchInfo {
  opponent: String!
  date: DateTime!
  time: String!
  competition: String!
  isHome: Boolean!
  hoursUntil: Int!
}

type LastMatchInfo {
  opponent: String!
  date: DateTime!
  result: String!
  competition: String!
  wasHome: Boolean!
  daysAgo: Int!
}

type LiveMatchInfo {
  fixtureId: Int!
  opponent: String!
  date: DateTime!
  time: String!
  competition: String!
  isHome: Boolean!
  score: String!
  minute: Int!
  status: String!
}

type MatchContextOutput {
  hasMatchToday: Boolean!
  hasMatchTomorrow: Boolean!
  isLive: Boolean!
  liveMatch: LiveMatchInfo
  nextMatch: NextMatchInfo
  lastMatch: LastMatchInfo
  isMatchday: Boolean!
  matchdayPhase: String
}

type ContentMeta {
  pageType: PageType!
  teamId: String
  teamIds: [String!]
  leagueId: String
  totalItems: Int!
  urgentCount: Int!
  highPriorityCount: Int!
  fetchedAt: DateTime!
}

enum PageType {
  SINGLE_TEAM
  LEAGUE
  MULTI_TEAM
  WOMENS
  GENERAL
}

type ContentSuggestionsResponse {
  success: Boolean!
  content: [ContentSuggestion!]!
  meta: ContentMeta!
  matchContext: MatchContextOutput
  error: String
}

type SourceContent {
  title: String!
  description: String!
  sourceUrl: String!
  sourceName: String!
  imageUrl: String
}

type GenerationMetadata {
  model: String!
  promptVersion: String!
  tokensUsed: Int!
  generatedAt: DateTime!
}

type PostFeedback {
  rating: Int!
  notes: String
}

type Post {
  id: ID!
  origin: PostOrigin!
  brandId: ID!
  contentSuggestionId: String
  contentType: ContentType!
  priority: ContentPriority!
  sourceContent: SourceContent!
  generatedText: String!
  finalText: String
  generation: GenerationMetadata!
  status: PostStatus!
  claimedBy: ID
  claimedAt: DateTime
  downloadedAt: DateTime
  rejectionReason: String
  feedback: PostFeedback
  templateData: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum PostOrigin {
  REACTIVE
  PROACTIVE
}

enum PostStatus {
  PENDING
  CLAIMED
  READY
  DOWNLOADED
  PUBLISHED
  REJECTED
}

type ThumbnailUploadResult {
  url: String!
  cdnUrl: String!
  path: String!
}

type BrandMemberUser {
  userId: ID!
  email: String!
  userName: String!
  name: String
  avatarUrl: String
}

type BrandMemberWithUser {
  id: ID!
  brandId: ID!
  userId: ID!
  role: BrandMemberRole!
  joinedAt: DateTime!
  user: BrandMemberUser
}

"""Role of a member in a brand"""
enum BrandMemberRole {
  OWNER
  EDITOR
  VIEWER
}

type BrandInvitationResult {
  id: ID!
  code: String!
  email: String
  role: BrandMemberRole!
  status: InvitationStatus!
  expiresAt: DateTime!
  createdAt: DateTime!
  inviteUrl: String!
}

"""Status of a brand invitation"""
enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  REVOKED
}

type BrandPublicInfo {
  id: ID!
  fanPageName: String!
  logo: String
  invitedRole: BrandMemberRole!
}

type BrandInvitationInfo {
  id: ID!
  brandId: ID!
  code: String!
  email: String
  role: BrandMemberRole!
  status: InvitationStatus!
  expiresAt: DateTime!
  createdAt: DateTime!
}

type MatchTeam {
  id: Int!
  name: String!
  logo: String
  goals: Int
  winner: Boolean
}

type MatchEvent {
  minute: Int!
  extraMinute: Int
  type: String!
  detail: String
  playerName: String
  playerPhoto: String
  assistName: String
  teamName: String!
  teamLogo: String
  comments: String
}

type MatchStatistic {
  type: String!
  home: String
  away: String
}

type MatchLineupPlayer {
  id: Int!
  name: String!
  number: Int!
  pos: String
  grid: String
  photo: String
}

type MatchLineup {
  teamName: String!
  teamLogo: String
  formation: String
  startXI: [MatchLineupPlayer!]!
  substitutes: [MatchLineupPlayer!]!
  coach: String
}

type LiveMatchData {
  fixtureId: Int!
  date: DateTime!
  status: String!
  statusLong: String!
  elapsed: Int
  venue: String
  referee: String
  league: String!
  leagueLogo: String
  round: String
  homeTeam: MatchTeam!
  awayTeam: MatchTeam!
  events: [MatchEvent!]!
  statistics: [MatchStatistic!]!
  lineups: [MatchLineup!]!
  halftimeHome: Int
  halftimeAway: Int
  fulltimeHome: Int
  fulltimeAway: Int
}

type LiveMatchResponse {
  success: Boolean!
  match: LiveMatchData
  error: String
  cachedAt: DateTime!
  cacheExpiresIn: Int!
}

type ViralContentOption {
  angle: String!
  emoji: String!
  content: String!
  hashtags: [String!]!
}

type ViralContentResponse {
  success: Boolean!
  eventSummary: String
  options: [ViralContentOption!]
  generatedAt: DateTime
  error: String
}

type Stream {
  id: ID!
  title: String!
  description: String
  sport: StreamSport!
  status: StreamStatus!
  userId: ID!
  rtmpUrl: String
  hlsUrl: String
  viewerCount: Int!
  homeTeam: String
  awayTeam: String
  homeScore: Int!
  awayScore: Int!
  thumbnailUrl: String
  startedAt: DateTime
  endedAt: DateTime
  scheduledAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""The sport type for a stream"""
enum StreamSport {
  SOCCER
  BASKETBALL
  TENNIS
  BASEBALL
  HOCKEY
  FOOTBALL
  OTHER
}

"""The status of a stream"""
enum StreamStatus {
  SCHEDULED
  LIVE
  ENDED
}

type Message {
  id: ID!
  streamId: ID!
  userId: ID!
  userName: String!
  content: String!
  type: MessageType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""The type of chat message"""
enum MessageType {
  TEXT
  EMOJI
  SYSTEM
}

type UserSubscription {
  id: ID!
  userId: ID!
  plan: SubscriptionPlan!
  status: SubscriptionStatus!
  stripeCustomerId: String
  stripeSubscriptionId: String
  currentPeriodEnd: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Subscription plan types"""
enum SubscriptionPlan {
  FREE
  PRO
  PREMIUM
}

"""Subscription status types"""
enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  TRIALING
}

type StreamAnalytics {
  id: ID!
  streamId: ID!
  peakViewers: Int!
  totalViews: Int!
  uniqueViewers: Int!
  totalMessages: Int!
  durationSeconds: Int!
  uniqueViewerIds: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ViewerCountUpdate {
  streamId: ID!
  viewerCount: Int!
}

type ScoreUpdate {
  streamId: ID!
  homeScore: Int!
  awayScore: Int!
  homeTeam: String
  awayTeam: String
}

type StreamStatusUpdate {
  streamId: ID!
  status: StreamStatus!
  startedAt: DateTime
  endedAt: DateTime
}

type CheckoutSessionOutput {
  url: String!
}

type Frase {
  id: ID!
  texto: String!
  autor: String
  categoria: FraseCategory!
  tono: FraseTone
  equipo: String
  emoji: String
  tag: String
  userId: ID!
  isPublic: Boolean!
  likesCount: Int!
  exportedImageUrl: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Categorias de frases de futbol"""
enum FraseCategory {
  CANCHA
  TECNICOS
  FUTBOLISTAS
  PERIODISTAS
  ARROGANCIA
  POLEMICAS
  MEMES
  MOTIVACIONAL
  PERSONAL
}

"""Tonos de las frases"""
enum FraseTone {
  SARCASTICO
  EPICO
  GRACIOSO
  POLEMICO
  MOTIVACIONAL
  ARROGANTE
  DRAMATICO
}

type GeneratedFrase {
  texto: String!
  autor: String
  emoji: String
  tag: String
}

type GenerateResponse {
  frases: [GeneratedFrase!]!
}

type Query {
  user(email: String!): UserOutputDto
  users: [UserOutputDto!]!
  me: UserOutputDto
  userByUserName(userName: String!): UserOutputDto
  isUserNameAvailable(userName: String!): Boolean!
  liveMatches: [LiveMatchOutputDto!]!
  lateMatches(options: LateMatchOptionsDto): [LiveMatchOutputDto!]!
  matchById(id: Float!): LiveMatchOutputDto
  myTeams: [Team!]!
  team(id: ID!): TeamWithMembers!
  teamByCode(code: String!): Team!
  teamMembers(teamId: ID!): [TeamMember!]!
  teamMembersWithUser(teamId: ID!): [TeamMemberWithUser!]!
  teamMatches(teamId: ID!): [TeamMatch!]!
  teamMatch(id: ID!): TeamMatch!
  matchMedia(matchId: ID!, filters: MediaFiltersInput): [Media!]!
  media(id: ID!): Media!
  myTaggedMedia(type: String): [Media!]!
  allMyMedia(type: String): [Media!]!
  userMedia(userId: ID!, type: String): [Media!]!
  profileStats(userId: ID): ProfileStats!
  allMyProfileStats: ProfileStats!
  pendingTags(mediaId: ID!): [PendingTag!]!
  teamPendingInvitations(teamId: ID!): [PendingTag!]!
  myPendingTags: [PendingTag!]!
  pendingTagByCode(inviteCode: String!): PendingTag
  notifications(limit: Int! = 50): [Notification!]!
  unreadNotificationCount: Int!
  myBrands: [Brand!]!
  activeBrand: Brand
  brand(id: ID!): Brand!
  hasBrands: Boolean!
  myTemplates(category: String): [Template!]!
  brandTemplates(brandId: ID!): [Template!]!
  presetTemplates(category: String): [Template!]!
  template(id: ID!): Template!
  templateByPresetId(presetId: String!): Template
  searchTemplates(query: String!): [Template!]!
  myDesigns: [Template!]!
  myPrivateTemplates: [Template!]!
  presetsByCategory(category: String): [Template!]!
  communityTemplates(category: String): [Template!]!
  publishedTemplates(category: String): [Template!]!
  contentSuggestions(input: FetchContentInput!): ContentSuggestionsResponse!
  activeBrandContent(limit: Float = 25): ContentSuggestionsResponse!
  brandMembers(brandId: ID!): [BrandMemberWithUser!]!
  brandInvitations(brandId: ID!): [BrandInvitationInfo!]!
  brandByInviteCode(code: String!): BrandPublicInfo!
  myBrandRole(brandId: ID!): BrandMemberRole
  post(id: ID!): Post!
  pendingPosts(brandId: ID!): [Post!]!
  brandPosts(brandId: ID!, filter: PostFilterInput): [Post!]!
  myClaimedPosts: [Post!]!
  myDownloadedPosts: [Post!]!
  liveMatch(fixtureId: Int!): LiveMatchResponse!
  liveFixtureId(teamApiId: Int!): Int
  stream(id: ID!): Stream!
  streams(status: StreamStatus): [Stream!]!
  liveStreams: [Stream!]!
  myStreams: [Stream!]!
  streamAnalytics(streamId: ID!): StreamAnalytics
  messages(streamId: ID!, limit: Int = 50, offset: Int = 0): [Message!]!
  mySubscription: UserSubscription

  """Obtener frases con filtros"""
  frases(filter: FilterFrasesInput): [Frase!]!

  """Obtener mis frases"""
  myFrases(filter: FilterFrasesInput): [Frase!]!

  """Obtener una frase por ID"""
  frase(id: ID!): Frase!

  """Obtener una frase aleatoria"""
  randomFrase(categoria: FraseCategory): Frase!

  """Obtener frases trending (más likes)"""
  trendingFrases(limit: Int! = 10): [Frase!]!
}

input LateMatchOptionsDto {
  minMinute: Int
  minPressureScore: Float
  requireRecentActivity: Boolean
  maxGoals: Int
}

input MediaFiltersInput {
  type: MediaType
  category: MediaCategory
  isHighlight: Boolean
}

input FetchContentInput {
  pageType: String = "single-team"
  teamId: String
  teamIds: [String!]
  leagueId: String
  sourceLanguages: [String!] = ["es", "en"]
  limit: Int = 25
  brandId: String

  """Enable AI-powered content analysis (Cerebro Futbolero)"""
  useAI: Boolean = true
}

input PostFilterInput {
  brandId: ID
  status: PostStatus
  limit: Int = 50
  offset: Int = 0
}

input FilterFrasesInput {
  categoria: FraseCategory
  tono: FraseTone
  search: String
  equipo: String
  onlyPublic: Boolean! = false
  limit: Int! = 20
  offset: Int! = 0
}

type Mutation {
  signin(userInput: SigninInputDto!): SigninOutputDto!
  Signup(userInput: SignupInputDto!): Boolean!
  ConfirmSignup(confirmInput: ConfirmSignupInputDto!): SigninOutputDto!
  forgotPassword(email: String!): Boolean!
  confirmForgotPassword(userInput: ConfirmPasswordInputDto!): Boolean!
  resendVerificationCode(email: String!): Boolean!
  addUser(userInput: AddUserInputDto!): UserOutputDto!
  googleSignin(idToken: String!): GoogleSigninResponse!
  completeProfile(updateProfileInput: UpdateProfileInputDto!): Boolean!
  updateUser(id: String!, updateUserInput: UpdateUserInput!): UserOutputDto!
  removeUser(id: String!): Boolean!
  createTeam(input: CreateTeamInput!): Team!
  updateTeam(id: ID!, input: UpdateTeamInput!): Team!
  deleteTeam(id: ID!): Boolean!
  joinTeam(code: String!): Team!
  leaveTeam(teamId: ID!): Boolean!
  removeTeamMember(teamId: ID!, userId: ID!): Boolean!
  updateMemberRole(teamId: ID!, userId: ID!, role: String!): TeamMember!
  createMatch(input: CreateMatchInput!): TeamMatch!

  """Get existing match for today or create one if none exists"""
  getOrCreateTodayMatch(teamId: ID!): TeamMatch!
  updateMatch(id: ID!, input: UpdateMatchInput!): TeamMatch!
  deleteMatch(id: ID!): Boolean!
  uploadPhoto(matchId: ID!, file: Upload!, category: String, isHighlight: Boolean = false): Media!
  uploadVideo(matchId: ID!, file: Upload!, category: String, isHighlight: Boolean = false): Media!
  uploadMedia(input: UploadMediaInput!): Media!
  batchUploadMedia(inputs: [UploadMediaInput!]!): [Media!]!
  updateMedia(id: ID!, input: UpdateMediaInput!): Media!
  deleteMedia(id: ID!): Boolean!
  toggleHighlight(mediaId: ID!): Media!
  tagUsersInMedia(mediaId: ID!, userIds: [ID!]!): Boolean!
  selfTagMedia(mediaId: ID!): Boolean!
  removeMediaTag(mediaId: ID!, userId: ID!): Boolean!
  createPendingTag(input: CreatePendingTagInput!): PendingTag!
  cancelPendingTag(id: ID!): Boolean!
  claimPendingTag(inviteCode: String!): PendingTag!

  """Claim all pending tags by phone number (called after registration)"""
  claimPendingTagsByPhone(phone: String!): Boolean!
  markNotificationAsRead(notificationId: ID!): Notification
  markAllNotificationsAsRead: Int!
  createBrand(input: CreateBrandInput!): Brand!
  updateBrand(input: UpdateBrandInput!): Brand!
  setActiveBrand(brandId: ID!): Brand!
  deleteBrand(id: ID!): Boolean!
  createTemplate(input: CreateTemplateInput!): Template!
  updateTemplate(input: UpdateTemplateInput!): Template!
  duplicateTemplate(templateId: ID!, newName: String): Template!
  deleteTemplate(id: ID!): Boolean!
  saveAsMyTemplate(designId: ID!, thumbnailUrl: String!): Template!
  publishAsTemplate(designId: ID!, thumbnailUrl: String!): Template!
  unpublishTemplate(templateId: ID!): Template!
  uploadTemplateThumbnail(base64Data: String!, templateId: ID!, format: String = "png"): ThumbnailUploadResult!
  uploadTemplateImage(base64Data: String!, templateId: ID!, imageId: String!, format: String = "jpg"): ThumbnailUploadResult!
  deleteTemplateImage(path: String!, templateId: ID!): Boolean!
  deleteTemplateImages(paths: [String!]!, templateId: ID!): Int!
  claimContent(contentId: String!, brandId: String!): ContentSuggestion!
  unclaimContent(contentId: String!, brandId: String!): ContentSuggestion!
  markContentDone(contentId: String!, brandId: String!): ContentSuggestion!
  markContentSeen(contentId: String!, brandId: String!): ContentSuggestion!
  inviteToBrand(input: InviteToBrandInput!): BrandInvitationResult!
  joinBrand(input: JoinBrandInput!): Brand!
  updateBrandMemberRole(input: UpdateBrandMemberRoleInput!): BrandMemberWithUser!
  removeBrandMember(brandId: ID!, userId: ID!): Boolean!
  leaveBrand(brandId: ID!): Boolean!
  revokeBrandInvitation(invitationId: ID!): Boolean!
  generatePost(input: GeneratePostInput!): Post!
  claimPost(id: ID!): Post!
  releasePost(id: ID!): Post!
  updatePostContent(input: UpdatePostContentInput!): Post!
  markPostReady(id: ID!): Post!
  markPostDownloaded(id: ID!): Post!
  markPostPublished(id: ID!): Post!
  rejectPost(input: RejectPostInput!): Post!
  submitPostFeedback(input: SubmitFeedbackInput!): Post!
  savePostTemplate(input: SavePostTemplateInput!): Post!
  generateViralContent(input: GenerateViralContentInput!): ViralContentResponse!
  createStream(input: CreateStreamInput!): Stream!
  updateStream(id: ID!, input: UpdateStreamInput!): Stream!
  startStream(id: ID!): Stream!
  endStream(id: ID!): Stream!
  updateScore(input: UpdateScoreInput!): Stream!
  deleteStream(id: ID!): Boolean!
  joinStream(streamId: ID!): Stream!
  leaveStream(streamId: ID!): Stream!
  regenerateStreamKey: String!
  sendMessage(input: SendMessageInput!): Message!
  createCheckoutSession: CheckoutSessionOutput!
  cancelSubscription: UserSubscription!

  """Generar frases con IA (requiere autenticación)"""
  generateFrases(input: GenerateFraseInput!): GenerateResponse!

  """Guardar una frase generada"""
  saveFrase(input: SaveFraseInput!): Frase!

  """Dar like a una frase"""
  toggleLike(id: ID!): Frase!

  """Cambiar visibilidad pública/privada de una frase"""
  togglePublic(id: ID!): Frase!

  """Eliminar una frase"""
  deleteFrase(id: ID!): Boolean!

  """Actualizar URL de imagen exportada"""
  updateExportedImage(id: ID!, imageUrl: String!): Frase!
}

input SigninInputDto {
  email: String!
  password: String!
}

input SignupInputDto {
  email: String!
  password: String!
}

input ConfirmSignupInputDto {
  email: String!
  verificationCode: String!
  password: String!
  phone: Float!
  userName: String!
  birthday: DateTime!
}

input ConfirmPasswordInputDto {
  email: String!
  newPassword: String!
  verificationCode: String!
}

input AddUserInputDto {
  email: String!
  password: String!
  phone: Float!
  role: UserRole
  name: String
}

input UpdateProfileInputDto {
  userName: String!
  birthday: DateTime!
  phone: String
  password: String!
  idToken: String!
}

input UpdateUserInput {
  roles: [UserRole!]
  userName: String
  name: String
  avatarUrl: String
}

input CreateTeamInput {
  name: String!
  color: TeamColor!
}

input UpdateTeamInput {
  name: String
  color: TeamColor
}

input CreateMatchInput {
  teamId: ID!
  date: DateTime!
  opponent: String
  location: String
}

input UpdateMatchInput {
  date: DateTime
  opponent: String
  location: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

input UploadMediaInput {
  matchId: ID!
  type: MediaType!
  url: String!
  thumbnailUrl: String
  category: MediaCategory
  isHighlight: Boolean = false
  duration: Float
}

input UpdateMediaInput {
  thumbnailUrl: String
  category: MediaCategory
  isHighlight: Boolean
  duration: Float
}

input CreatePendingTagInput {
  mediaId: ID!
  name: String!
  phone: String
}

input CreateBrandInput {
  fanPageId: String!
  fanPageName: String!
  tokens: ThemeTokensInput!
  watermark: WatermarkConfigInput!
  contentPreferences: ContentPreferencesInput
  isActive: Boolean = false
}

input ThemeTokensInput {
  primaryColor: String!
  secondaryColor: String!
  accentColor: String!
  backgroundColor: String!
  textColor: String!
  logo: String!
  fontPrimary: String!
  fontSecondary: String!
  fanPageName: String!
}

input WatermarkConfigInput {
  style: String!
  position: String!
  customText: String
  showBackground: Boolean!
  backgroundColor: String
  size: String!
}

input ContentPreferencesInput {
  pageType: String
  gender: String
  teamId: String
  leagueId: String
  additionalTeams: [String!]
  contentTypes: [String!]!
  publishLanguage: String!
  sourceLanguages: [String!]!
  notifyBreaking: Boolean!
  notifyMatchday: Boolean!
}

input UpdateBrandInput {
  id: ID!
  fanPageName: String
  tokens: ThemeTokensInput
  watermark: WatermarkConfigInput
  contentPreferences: ContentPreferencesInput
  isActive: Boolean
}

input CreateTemplateInput {
  brandId: ID
  name: String!
  description: String
  category: String!
  thumbnail: String
  width: Int!
  height: Int!
  backgroundColor: String!
  templateData: JSON!
  tags: [String!]
  isPublished: Boolean = false
  presetId: String
  type: String = "template"
}

input UpdateTemplateInput {
  id: ID!
  name: String
  description: String
  category: String
  thumbnail: String
  width: Int
  height: Int
  backgroundColor: String
  templateData: JSON
  tags: [String!]
  isPublished: Boolean
}

input InviteToBrandInput {
  brandId: ID!
  role: BrandMemberRole!
  email: String
}

input JoinBrandInput {
  code: String!
}

input UpdateBrandMemberRoleInput {
  brandId: ID!
  userId: ID!
  role: BrandMemberRole!
}

input GeneratePostInput {
  suggestionId: String!
  brandId: ID!
}

input UpdatePostContentInput {
  postId: ID!
  finalText: String!
}

input RejectPostInput {
  postId: ID!
  reason: String
}

input SubmitFeedbackInput {
  postId: ID!
  rating: Int!
  notes: String
}

input SavePostTemplateInput {
  postId: ID!
  templateData: JSON!
}

input GenerateViralContentInput {
  eventType: MatchEventType!
  minute: Int!
  playerName: String
  assistName: String
  detail: String
  homeTeam: String!
  awayTeam: String!
  homeScore: Int!
  awayScore: Int!
  competition: String!
  round: String
  venue: String
  isHome: Boolean!
  ourTeam: String!
  possession: PossessionInput
  shots: ShotsInput
  shotsOnTarget: ShotsInput
}

enum MatchEventType {
  GOAL
  CARD
  SUBSTITUTION
  VAR
  HALFTIME
  FULLTIME
  KICKOFF
}

input PossessionInput {
  home: Int!
  away: Int!
}

input ShotsInput {
  home: Int!
  away: Int!
}

input CreateStreamInput {
  title: String!
  description: String
  sport: StreamSport = SOCCER
  homeTeam: String
  awayTeam: String
  thumbnailUrl: String
  scheduledAt: DateTime
}

input UpdateStreamInput {
  title: String
  description: String
  sport: StreamSport
  homeTeam: String
  awayTeam: String
  thumbnailUrl: String
  scheduledAt: DateTime
}

input UpdateScoreInput {
  streamId: ID!
  homeScore: Int!
  awayScore: Int!
}

input SendMessageInput {
  streamId: ID!
  content: String!
  type: MessageType = TEXT
}

input GenerateFraseInput {
  categoria: FraseCategory!
  tono: FraseTone
  equipo: String
  count: Int! = 3
}

input SaveFraseInput {
  texto: String!
  autor: String
  categoria: FraseCategory!
  tono: FraseTone
  equipo: String
  emoji: String
  tag: String
  exportedImageUrl: String
}

type Subscription {
  viewerCountUpdated(streamId: ID!): ViewerCountUpdate!
  scoreUpdated(streamId: ID!): ScoreUpdate!
  streamStatusChanged(streamId: ID!): StreamStatusUpdate!
  messageAdded(streamId: ID!): Message!
}