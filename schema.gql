# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type User {
  userId: ID!
  email: String!
  birthday: DateTime
  phone: String!
  roles: [UserRole!]!
  isOnboardingCompleted: Boolean!
  createdAt: Int!
  updatedAt: Int!
  userName: String!
  name: String
  avatarUrl: String
  googleId: String
  authProvider: String
  activeBrandId: ID
  plan: String
  streamsThisMonth: Int!
  stripeCustomerId: String
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

"""The roles a user can have in the system"""
enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

type SigninOutputDto {
  id: ID!
  access_token: String!
  isOnboardingCompleted: Boolean!
  avatarUrl: String
  name: String
  userName: String
  roles: [UserRole!]!
}

type UserOutputDto {
  id: String!
  email: String!
  userName: String
  name: String
  phone: String
  avatarUrl: String
  roles: [UserRole!]!
}

type GoogleSigninResponse {
  email: String!
  userName: String!
  name: String
  avatarUrl: String
  isProfileCompleted: Boolean!
}

type TimelineEventDto {
  type: String!
  detail: String!
  team: String!
  player: String
  assist: String
  minute: Int!
  isHome: Boolean
  importance: Float
}

type BettingAnalysisDto {
  recommendedBet: String!
  confidence: Int!
  reason: String!
  odds: Float!
  timestamp: String!
}

type PossessionDto {
  home: Int!
  away: Int!
}

type LiveMatchOutputDto {
  id: Int!
  homeTeam: String!
  awayTeam: String!
  minute: Int
  scoreHome: Int!
  scoreAway: Int!
  shots: Int
  shotsOnTarget: Int
  dangerousAttacks: Int
  corners: Int
  pressureScore: Float
  recentActivityScore: Float
  hasRecentActivity: Boolean
  possession: PossessionDto
  xG: Float
  attacks: PossessionDto
  bigChances: PossessionDto
  bettingAnalysis: BettingAnalysisDto
  marketAvailable: Boolean
  lastEventType: String
  isGoodForOver05: Boolean
  isGoodForOver15: Boolean
  isLateMatch: Boolean
  bookmakers: [String!]
  timeline: [TimelineEventDto!]
  state: MatchState
  yellowCards: Int
  redCards: Int
  offsides: Int
  shotsOffTarget: Int
}

enum MatchState {
  NotStarted
  FirstHalf
  HalfTime
  SecondHalf
  Finished
  Normal
  Potential
  ReadyToBet
  NoBet
  NoLateValue
  ModerateLateValue
  HighLateValue
}

type Team {
  id: ID!
  name: String!
  color: TeamColor!
  code: String!
  createdBy: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  matchCount: Int
  mediaCount: Int
  memberCount: Int
}

"""Available team colors"""
enum TeamColor {
  GREEN
  BLUE
  RED
  YELLOW
  PURPLE
  ORANGE
  PINK
  BLACK
  WHITE
}

type TeamMember {
  id: ID!
  teamId: ID!
  userId: ID!
  role: MemberRole!
  joinedAt: DateTime!
}

"""Role of a member in a team"""
enum MemberRole {
  ADMIN
  MEMBER
}

type TeamMatch {
  id: ID!
  teamId: ID!
  date: DateTime!
  opponent: String
  location: String
  createdBy: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  photoCount: Int
  videoCount: Int
  highlightCount: Int
}

type MediaTag {
  id: ID!
  mediaId: ID!
  userId: ID!
  taggedBy: ID!
  createdAt: DateTime!
}

type Media {
  id: ID!
  matchId: ID!
  uploadedBy: ID!
  type: MediaType!
  url: String!
  thumbnailUrl: String
  category: MediaCategory
  isHighlight: Boolean!
  duration: Float
  videoId: String
  storagePath: String
  embedUrl: String
  processingStatus: String
  createdAt: DateTime!
  updatedAt: DateTime!
  tags: [MediaTag!]
  uploader: User
}

"""Type of media content"""
enum MediaType {
  PHOTO
  VIDEO
}

"""Category of media content"""
enum MediaCategory {
  GOAL
  PLAY
  FAIL
}

type Notification {
  id: ID!
  userId: ID!
  type: NotificationType!
  title: String!
  message: String!
  imageUrl: String
  actionUrl: String
  isRead: Boolean!
  emailSent: Boolean!
  actorId: ID
  mediaId: ID
  teamId: ID
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Type of notification"""
enum NotificationType {
  TAG
  TEAM_JOIN
  INVITE_ACCEPTED
  NEW_MEDIA
  MENTION
}

type PendingTag {
  id: ID!
  mediaId: ID!
  teamId: ID!
  name: String!
  phone: String
  inviteCode: String!
  status: PendingTagStatus!
  createdBy: ID!
  claimedBy: ID
  claimedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  inviteUrl: String!
  media: Media
  createdByUser: User
}

"""Status of a pending tag invitation"""
enum PendingTagStatus {
  PENDING
  CLAIMED
  CANCELLED
}

type TeamMemberWithUser {
  id: ID!
  teamId: ID!
  userId: ID!
  role: MemberRole!
  joinedAt: DateTime!
  user: User
}

type TeamWithMembers {
  id: ID!
  name: String!
  color: TeamColor!
  code: String!
  createdBy: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  matchCount: Int
  mediaCount: Int
  memberCount: Int
  members: [TeamMemberWithUser!]!
}

type ProfileStats {
  goalCount: Int!
  videoCount: Int!
  photoCount: Int!
}

type ThemeTokens {
  primaryColor: String!
  secondaryColor: String!
  accentColor: String!
  backgroundColor: String!
  textColor: String!
  logo: String!
  fontPrimary: String!
  fontSecondary: String!
  fanPageName: String!
}

type WatermarkConfig {
  style: String!
  position: String!
  customText: String
  showBackground: Boolean!
  backgroundColor: String
  size: String!
}

type ContentPreferences {
  pageType: String
  gender: String
  teamId: String
  leagueId: String
  additionalTeams: [String!]
  contentTypes: [String!]!
  publishLanguage: String!
  sourceLanguages: [String!]!
  notifyBreaking: Boolean!
  notifyMatchday: Boolean!
}

type Brand {
  id: ID!
  userId: ID!
  fanPageId: String!
  fanPageName: String!
  tokens: ThemeTokens!
  watermark: WatermarkConfig!
  contentPreferences: ContentPreferences
  isActive: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Template {
  id: ID!
  userId: ID!
  brandId: ID
  name: String!
  description: String
  category: String!
  thumbnail: String
  width: Int!
  height: Int!
  backgroundColor: String!
  templateData: JSON!
  tags: [String!]
  isPublished: Boolean!
  isPreset: Boolean!
  presetId: String
  type: String!
  postId: ID
  presetCategory: String
  imageAssets: [String!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type ClaimedBy {
  id: ID!
  name: String!
  avatar: String
}

type ContentSuggestion {
  id: ID!
  type: ContentType!
  priority: ContentPriority!
  title: String!
  originalTitle: String
  rewrittenTitle: String
  description: String!
  originalDescription: String
  source: String
  sourceLanguage: String
  sourceUrl: String
  imageUrl: String
  timestamp: DateTime!
  suggestedTemplates: [String!]!
  suggestedCaption: String
  hashtags: [String!]
  viralScore: Int
  relevanceScore: Int
  isRelevant: Boolean
  wasProcessedByAI: Boolean
  status: ContentStatus!
  claimedBy: ClaimedBy
  claimedAt: DateTime
  seenBy: [String!]!
}

enum ContentType {
  BREAKING
  MATCHDAY
  RESULT
  TRANSFER
  INJURY
  STATS
  QUOTE
  MEME
  THROWBACK
  RUMOR
  GENERAL
}

enum ContentPriority {
  URGENT
  HIGH
  NORMAL
  LOW
}

enum ContentStatus {
  AVAILABLE
  CLAIMED
  IN_PROGRESS
  DONE
  DISMISSED
}

type NextMatchInfo {
  opponent: String!
  date: DateTime!
  time: String!
  competition: String!
  isHome: Boolean!
  hoursUntil: Int!
}

type LastMatchInfo {
  opponent: String!
  date: DateTime!
  result: String!
  competition: String!
  wasHome: Boolean!
  daysAgo: Int!
}

type LiveMatchInfo {
  fixtureId: Int!
  opponent: String!
  date: DateTime!
  time: String!
  competition: String!
  isHome: Boolean!
  score: String!
  minute: Int!
  status: String!
}

type MatchContextOutput {
  hasMatchToday: Boolean!
  hasMatchTomorrow: Boolean!
  isLive: Boolean!
  liveMatch: LiveMatchInfo
  nextMatch: NextMatchInfo
  lastMatch: LastMatchInfo
  isMatchday: Boolean!
  matchdayPhase: String
}

type ContentMeta {
  pageType: PageType!
  teamId: String
  teamIds: [String!]
  leagueId: String
  totalItems: Int!
  urgentCount: Int!
  highPriorityCount: Int!
  fetchedAt: DateTime!
}

enum PageType {
  SINGLE_TEAM
  LEAGUE
  MULTI_TEAM
  WOMENS
  GENERAL
}

type ContentSuggestionsResponse {
  success: Boolean!
  content: [ContentSuggestion!]!
  meta: ContentMeta!
  matchContext: MatchContextOutput
  error: String
}

type SourceContent {
  title: String!
  description: String!
  sourceUrl: String!
  sourceName: String!
  imageUrl: String
}

type GenerationMetadata {
  model: String!
  promptVersion: String!
  tokensUsed: Int!
  generatedAt: DateTime!
}

type PostFeedback {
  rating: Int!
  notes: String
}

type Post {
  id: ID!
  origin: PostOrigin!
  brandId: ID!
  contentSuggestionId: String
  contentType: ContentType!
  priority: ContentPriority!
  sourceContent: SourceContent!
  generatedText: String!
  finalText: String
  generation: GenerationMetadata!
  status: PostStatus!
  claimedBy: ID
  claimedAt: DateTime
  downloadedAt: DateTime
  rejectionReason: String
  feedback: PostFeedback
  templateData: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum PostOrigin {
  REACTIVE
  PROACTIVE
}

enum PostStatus {
  PENDING
  CLAIMED
  READY
  DOWNLOADED
  PUBLISHED
  REJECTED
}

type ThumbnailUploadResult {
  url: String!
  cdnUrl: String!
  path: String!
}

type BrandMemberUser {
  userId: ID!
  email: String!
  userName: String!
  name: String
  avatarUrl: String
}

type BrandMemberWithUser {
  id: ID!
  brandId: ID!
  userId: ID!
  role: BrandMemberRole!
  joinedAt: DateTime!
  user: BrandMemberUser
}

"""Role of a member in a brand"""
enum BrandMemberRole {
  OWNER
  EDITOR
  VIEWER
}

type BrandInvitationResult {
  id: ID!
  code: String!
  email: String
  role: BrandMemberRole!
  status: InvitationStatus!
  expiresAt: DateTime!
  createdAt: DateTime!
  inviteUrl: String!
}

"""Status of a brand invitation"""
enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  REVOKED
}

type BrandPublicInfo {
  id: ID!
  fanPageName: String!
  logo: String
  invitedRole: BrandMemberRole!
}

type BrandInvitationInfo {
  id: ID!
  brandId: ID!
  code: String!
  email: String
  role: BrandMemberRole!
  status: InvitationStatus!
  expiresAt: DateTime!
  createdAt: DateTime!
}

type MatchTeam {
  id: Int!
  name: String!
  logo: String
  goals: Int
  winner: Boolean
}

type MatchEvent {
  minute: Int!
  extraMinute: Int
  type: String!
  detail: String
  playerName: String
  playerPhoto: String
  assistName: String
  teamName: String!
  teamLogo: String
  comments: String
}

type MatchStatistic {
  type: String!
  home: String
  away: String
}

type MatchLineupPlayer {
  id: Int!
  name: String!
  number: Int!
  pos: String
  grid: String
  photo: String
}

type MatchLineup {
  teamName: String!
  teamLogo: String
  formation: String
  startXI: [MatchLineupPlayer!]!
  substitutes: [MatchLineupPlayer!]!
  coach: String
}

type LiveMatchData {
  fixtureId: Int!
  date: DateTime!
  status: String!
  statusLong: String!
  elapsed: Int
  venue: String
  referee: String
  league: String!
  leagueLogo: String
  round: String
  homeTeam: MatchTeam!
  awayTeam: MatchTeam!
  events: [MatchEvent!]!
  statistics: [MatchStatistic!]!
  lineups: [MatchLineup!]!
  halftimeHome: Int
  halftimeAway: Int
  fulltimeHome: Int
  fulltimeAway: Int
}

type LiveMatchResponse {
  success: Boolean!
  match: LiveMatchData
  error: String
  cachedAt: DateTime!
  cacheExpiresIn: Int!
}

type ViralContentOption {
  angle: String!
  emoji: String!
  content: String!
  hashtags: [String!]!
}

type ViralContentResponse {
  success: Boolean!
  eventSummary: String
  options: [ViralContentOption!]
  generatedAt: DateTime
  error: String
}

type Stream {
  id: ID!
  title: String!
  description: String
  sport: StreamSport!
  status: StreamStatus!
  userId: ID!
  rtmpUrl: String
  hlsUrl: String
  viewerCount: Int!
  homeTeam: String
  awayTeam: String
  homeScore: Int!
  awayScore: Int!
  thumbnailUrl: String
  startedAt: DateTime
  endedAt: DateTime
  scheduledAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""The sport type for a stream"""
enum StreamSport {
  SOCCER
  BASKETBALL
  TENNIS
  BASEBALL
  HOCKEY
  FOOTBALL
  OTHER
}

"""The status of a stream"""
enum StreamStatus {
  SCHEDULED
  LIVE
  ENDED
}

type Message {
  id: ID!
  streamId: ID!
  userId: ID!
  userName: String!
  content: String!
  type: MessageType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""The type of chat message"""
enum MessageType {
  TEXT
  EMOJI
  SYSTEM
}

type UserSubscription {
  id: ID!
  userId: ID!
  plan: SubscriptionPlan!
  status: SubscriptionStatus!
  stripeCustomerId: String
  stripeSubscriptionId: String
  currentPeriodEnd: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Subscription plan types"""
enum SubscriptionPlan {
  FREE
  PRO
  PREMIUM
}

"""Subscription status types"""
enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  TRIALING
}

type StreamAnalytics {
  id: ID!
  streamId: ID!
  peakViewers: Int!
  totalViews: Int!
  uniqueViewers: Int!
  totalMessages: Int!
  durationSeconds: Int!
  uniqueViewerIds: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ViewerCountUpdate {
  streamId: ID!
  viewerCount: Int!
}

type ScoreUpdate {
  streamId: ID!
  homeScore: Int!
  awayScore: Int!
  homeTeam: String
  awayTeam: String
}

type StreamStatusUpdate {
  streamId: ID!
  status: StreamStatus!
  startedAt: DateTime
  endedAt: DateTime
}

type CheckoutSessionOutput {
  url: String!
}

type Frase {
  id: ID!
  texto: String!
  autor: String
  categoria: FraseCategory!
  tono: FraseTone
  equipo: String
  emoji: String
  tag: String
  userId: ID!
  isPublic: Boolean!
  likesCount: Int!
  exportedImageUrl: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Categorias de frases de futbol"""
enum FraseCategory {
  CANCHA
  TECNICOS
  FUTBOLISTAS
  PERIODISTAS
  ARROGANCIA
  POLEMICAS
  MEMES
  MOTIVACIONAL
  PERSONAL
}

"""Tonos de las frases"""
enum FraseTone {
  SARCASTICO
  EPICO
  GRACIOSO
  POLEMICO
  MOTIVACIONAL
  ARROGANTE
  DRAMATICO
}

type GeneratedFrase {
  texto: String!
  autor: String
  emoji: String
  tag: String
}

type GenerateResponse {
  frases: [GeneratedFrase!]!
}

type GoalGuruLeagueDto {
  id: String!
  name: String!
  flag: String!
  search: String!
  g1hRating: String
  avgG1H: Float
}

type GoalGuruMatchDto {
  home: String!
  away: String!
  date: String!
  time: String!
  comp: String!
}

type G1HStatsDto {
  homeG1HPercent: Int
  awayConcedeG1HPercent: Int
  avgMinuteFirstGoal: Int
  homeAvg1HGoals: Float
  fhpiScore: Float
}

type PickDetailDto {
  match: String!
  mercado: String!
  odds: Float!
  confianza: Int!
  stake: Int!
  riesgo: RiskLevel!
  razon: String!
  patron: String
  g1hStats: G1HStatsDto
  capas: String
  c1: String
  c2: String
  maestro: String
  score: String
  alt: String
  alerta: String
}

"""Risk level for Goal Guru betting picks"""
enum RiskLevel {
  BAJO
  MEDIO
  ALTO
}

type SkipDetailDto {
  match: String!
  razon: String!
}

type AnalysisResultDto {
  picks: [PickDetailDto!]!
  skip: [SkipDetailDto!]!
  mejorPick: String
  alertas: String
  top: String
  parlay: String
  bank: String
}

type FhgSelectionDto {
  id: ID!
  matchId: ID!
  predictionId: ID!
  homeTeam: String!
  awayTeam: String!
  leagueCode: String!
  date: DateTime!
  kickoffTime: String!
  signal: FhgSignal!
  marginValor: Float!
  pReal: Float!
  edgeScore: Int!
  stakePercentage: Float!
  oddsAtSelection: Float!
  bookmakerUsed: String
  outcome: FhgOutcome!
  closingOdds: Float
  clv: Float
  profitLoss: Float
  settledAt: DateTime
  actualGoals1H: Int
  minuteFirstGoal: Int
  createdAt: DateTime!
}

"""Signal strength for FHG selections (A=best, NONE=skip)"""
enum FhgSignal {
  A
  B
  C
  NONE
}

"""Outcome of an FHG selection"""
enum FhgOutcome {
  PENDING
  WON
  LOST
  VOID
}

type FhgSelectionHistoryDto {
  selections: [FhgSelectionDto!]!
  total: Int!
  offset: Int!
  limit: Int!
}

type FhgFactorDto {
  name: String!
  value: Float!
  reason: String!
}

type FhgEdgeBreakdownDto {
  dataQualityScore: Int
  patternScore: Int
  contextScore: Int
  valueScore: Int
}

type FhgPredictionDetailDto {
  id: ID!
  matchId: ID!
  homeTeam: String!
  awayTeam: String!
  leagueCode: String!
  date: DateTime!
  pBase: Float!
  leagueAvgG1H: Float!
  homeG1HRate: Float!
  awayConcedeG1HRate: Float!
  pReal: Float!
  factors: [FhgFactorDto!]!
  leagueFactor: Float
  momentumFactor: Float
  aggressionFactor: Float
  vulnerabilityFactor: Float
  contextFactor: Float
  formFactor: Float
  totalFactorMultiplier: Float
  edgeScore: Int!
  edgeBreakdown: FhgEdgeBreakdownDto
  confidenceLevel: String
  warnings: [String!]!
  createdAt: DateTime!
}

type FhgLeagueMetricsDto {
  leagueCode: String!
  leagueName: String!
  totalSelections: Int!
  won: Int!
  lost: Int!
  hitRate: Float!
  avgClv: Float!
  roi: Float!
}

type FhgSignalMetricsDto {
  signal: String!
  totalSelections: Int!
  won: Int!
  lost: Int!
  hitRate: Float!
  avgClv: Float!
  roi: Float!
}

type FhgAlertDto {
  severity: String!
  message: String!
  recommendation: String!
}

type FhgHealthDto {
  id: ID!
  status: FhgStatus!
  reportDate: DateTime!
  periodStart: DateTime!
  periodEnd: DateTime!
  totalSelections: Int!
  settledSelections: Int!
  pendingSelections: Int!
  won: Int!
  lost: Int!
  voided: Int!
  hitRate: Float!
  avgClv: Float!
  roi: Float!
  totalProfitLoss: Float!
  totalStaked: Float!
  clv7d: Float
  clv30d: Float
  clvAllTime: Float
  byLeague: [FhgLeagueMetricsDto!]!
  bySignal: [FhgSignalMetricsDto!]!
  alerts: [FhgAlertDto!]!
}

"""Health status of FHG system based on CLV"""
enum FhgStatus {
  GREEN
  YELLOW
  RED
}

type DailyPipelineResultDto {
  pipelineId: String!
  date: DateTime!
  matchesAnalyzed: Int!
  candidatesFound: Int!
  selectionsCreated: Int!
  selections: [FhgSelectionDto!]!
  skippedReasons: [String!]!
  executionTimeMs: Int!
  success: Boolean!
  error: String
}

type SettlementResultDto {
  settled: Int!
  won: Int!
  lost: Int!
  voided: Int!
  settledSelections: [FhgSelectionDto!]!
  success: Boolean!
  error: String
}

type RefreshResultDto {
  updated: Int!
  created: Int!
  failed: Int!
  success: Boolean!
  error: String
}

type FhgMatchCandidateDto {
  matchId: String!
  homeTeam: String!
  awayTeam: String!
  leagueCode: String!
  date: DateTime!
  kickoffTime: String!
  pReal: Float
  edgeScore: Float
  bestOdds: Float
  marginValor: Float
  signal: String
  hasOdds: Boolean!
  hasPrediction: Boolean!
}

type FhgLogEntryDto {
  id: ID!
  level: FhgLogLevel!
  category: FhgLogCategory!
  message: String!
  data: JSON
  matchId: String
  pipelineId: String
  selectionId: String
  timestamp: DateTime!
}

"""Log level for FHG system logs"""
enum FhgLogLevel {
  DEBUG
  INFO
  WARN
  ERROR
}

"""Category for FHG system logs"""
enum FhgLogCategory {
  PREDICTION
  VALUE
  PIPELINE
  SELECTION
  SETTLEMENT
  HEALTH
  ODDS
  STATS
  CRON
}

type FhgLeagueDto {
  id: ID!
  code: String!
  name: String!
  tier: FhgTier!
  avgG1H: Float!
  apiFootballId: Float
  footballDataCode: String
  active: Boolean!
  flag: String
  g1hRateHome: Float
  g1hRateAway: Float
  avgMinuteFirstGoal: Float
  lastStatsUpdate: DateTime
}

"""League tier classification for G1H betting potential"""
enum FhgTier {
  MAX
  HIGH
  MEDIUM
  LOW
}

type FhgMatchContext {
  motivation: String
  isDerby: Boolean!
  homeRestDays: Int
  awayRestDays: Int
  homeLastResult: String
  awayLastResult: String
  homeLeaguePosition: Int
  awayLeaguePosition: Int
  weather: String
}

type FhgBookmakerOdds {
  bookmaker: String!
  g1hYes: Float
  g1hNo: Float
  lastUpdate: DateTime
}

type FhgFactor {
  name: String!
  value: Float!
  reason: String!
}

type FhgEdgeBreakdown {
  dataQualityScore: Int
  patternScore: Int
  contextScore: Int
  valueScore: Int
}

type FhgRecentForm {
  date: DateTime!
  opponent: String!
  isHome: Boolean!
  hadG1H: Boolean!
  minuteFirstGoal: Int
  goalsScored1H: Int!
  goalsConceded1H: Int!
}

type FhgLeagueHealthMetrics {
  leagueCode: String!
  leagueName: String!
  totalSelections: Int!
  won: Int!
  lost: Int!
  hitRate: Float!
  avgClv: Float!
  roi: Float!
}

type FhgSignalHealthMetrics {
  signal: String!
  totalSelections: Int!
  won: Int!
  lost: Int!
  hitRate: Float!
  avgClv: Float!
  roi: Float!
}

type FhgHealthAlert {
  severity: String!
  message: String!
  recommendation: String!
}

type Query {
  user(email: String!): UserOutputDto
  users: [UserOutputDto!]!
  me: UserOutputDto
  userByUserName(userName: String!): UserOutputDto
  isUserNameAvailable(userName: String!): Boolean!
  liveMatches: [LiveMatchOutputDto!]!
  lateMatches(options: LateMatchOptionsDto): [LiveMatchOutputDto!]!
  matchById(id: Float!): LiveMatchOutputDto
  myTeams: [Team!]!
  team(id: ID!): TeamWithMembers!
  teamByCode(code: String!): Team!
  teamMembers(teamId: ID!): [TeamMember!]!
  teamMembersWithUser(teamId: ID!): [TeamMemberWithUser!]!
  teamMatches(teamId: ID!): [TeamMatch!]!
  teamMatch(id: ID!): TeamMatch!
  matchMedia(matchId: ID!, filters: MediaFiltersInput): [Media!]!
  media(id: ID!): Media!
  myTaggedMedia(type: String): [Media!]!
  allMyMedia(type: String): [Media!]!
  userMedia(userId: ID!, type: String): [Media!]!
  profileStats(userId: ID): ProfileStats!
  allMyProfileStats: ProfileStats!
  allMyTeamsMedia(type: String, limit: Float = 50, offset: Float = 0): [Media!]!
  pendingTags(mediaId: ID!): [PendingTag!]!
  teamPendingInvitations(teamId: ID!): [PendingTag!]!
  myPendingTags: [PendingTag!]!
  pendingTagByCode(inviteCode: String!): PendingTag
  notifications(limit: Int! = 50): [Notification!]!
  unreadNotificationCount: Int!
  myBrands: [Brand!]!
  activeBrand: Brand
  brand(id: ID!): Brand!
  hasBrands: Boolean!
  myTemplates(category: String): [Template!]!
  brandTemplates(brandId: ID!): [Template!]!
  presetTemplates(category: String): [Template!]!
  template(id: ID!): Template!
  templateByPresetId(presetId: String!): Template
  searchTemplates(query: String!): [Template!]!
  myDesigns: [Template!]!
  myPrivateTemplates: [Template!]!
  presetsByCategory(category: String): [Template!]!
  communityTemplates(category: String): [Template!]!
  publishedTemplates(category: String): [Template!]!
  contentSuggestions(input: FetchContentInput!): ContentSuggestionsResponse!
  activeBrandContent(limit: Float = 25): ContentSuggestionsResponse!
  brandMembers(brandId: ID!): [BrandMemberWithUser!]!
  brandInvitations(brandId: ID!): [BrandInvitationInfo!]!
  brandByInviteCode(code: String!): BrandPublicInfo!
  myBrandRole(brandId: ID!): BrandMemberRole
  post(id: ID!): Post!
  pendingPosts(brandId: ID!): [Post!]!
  brandPosts(brandId: ID!, filter: PostFilterInput): [Post!]!
  myClaimedPosts: [Post!]!
  myDownloadedPosts: [Post!]!
  liveMatch(fixtureId: Int!): LiveMatchResponse!
  liveFixtureId(teamApiId: Int!): Int
  stream(id: ID!): Stream!
  streams(status: StreamStatus): [Stream!]!
  liveStreams: [Stream!]!
  myStreams: [Stream!]!
  streamAnalytics(streamId: ID!): StreamAnalytics
  messages(streamId: ID!, limit: Int = 50, offset: Int = 0): [Message!]!
  mySubscription: UserSubscription

  """Obtener frases con filtros"""
  frases(filter: FilterFrasesInput): [Frase!]!

  """Obtener mis frases"""
  myFrases(filter: FilterFrasesInput): [Frase!]!

  """Obtener una frase por ID"""
  frase(id: ID!): Frase!

  """Obtener una frase aleatoria"""
  randomFrase(categoria: FraseCategory): Frase!

  """Obtener frases trending (más likes)"""
  trendingFrases(limit: Int! = 10): [Frase!]!
  goalGuruLeagues: [GoalGuruLeagueDto!]!
  findGoalGuruMatches(leagueId: String!): [GoalGuruMatchDto!]!

  """Get FHG selections for today"""
  fhgTodaySelections: [FhgSelectionDto!]!

  """Get FHG selections for a specific date (YYYY-MM-DD)"""
  fhgSelectionsByDate(date: String!): [FhgSelectionDto!]!

  """Get FHG selections for current week (Monday to Sunday)"""
  fhgSelectionsThisWeek: [FhgSelectionDto!]!

  """Get paginated FHG selection history"""
  fhgSelectionHistory(limit: Int, offset: Int): FhgSelectionHistoryDto!

  """Get the latest FHG health report with CLV metrics"""
  fhgHealthReport: FhgHealthDto!

  """Get active leagues for FHG analysis"""
  fhgActiveLeagues: [FhgLeagueDto!]!

  """Get match candidates for analysis (with predictions and odds status)"""
  fhgMatchCandidates(date: String): [FhgMatchCandidateDto!]!

  """Get detailed prediction for a specific match"""
  fhgMatchPrediction(matchId: ID!): FhgPredictionDetailDto

  """Get recent FHG logs for transparency"""
  fhgRecentLogs(limit: Int, category: String): [FhgLogEntryDto!]!

  """Get FHG logs with filters"""
  fhgLogs(filter: FhgLogFilterInput): [FhgLogEntryDto!]!
}

input LateMatchOptionsDto {
  minMinute: Int
  minPressureScore: Float
  requireRecentActivity: Boolean
  maxGoals: Int
}

input MediaFiltersInput {
  type: MediaType
  category: MediaCategory
  isHighlight: Boolean
}

input FetchContentInput {
  pageType: String = "single-team"
  teamId: String
  teamIds: [String!]
  leagueId: String
  sourceLanguages: [String!] = ["es", "en"]
  limit: Int = 25
  brandId: String

  """Enable AI-powered content analysis (Cerebro Futbolero)"""
  useAI: Boolean = true
}

input PostFilterInput {
  brandId: ID
  status: PostStatus
  limit: Int = 50
  offset: Int = 0
}

input FilterFrasesInput {
  categoria: FraseCategory
  tono: FraseTone
  search: String
  equipo: String
  onlyPublic: Boolean! = false
  limit: Int! = 20
  offset: Int! = 0
}

input FhgLogFilterInput {
  level: FhgLogLevel
  category: FhgLogCategory
  matchId: String
  pipelineId: String
  startDate: DateTime
  endDate: DateTime
  limit: Int
  offset: Int
}

type Mutation {
  signin(userInput: SigninInputDto!): SigninOutputDto!
  Signup(userInput: SignupInputDto!): Boolean!
  ConfirmSignup(confirmInput: ConfirmSignupInputDto!): SigninOutputDto!
  forgotPassword(email: String!): Boolean!
  confirmForgotPassword(userInput: ConfirmPasswordInputDto!): Boolean!
  resendVerificationCode(email: String!): Boolean!
  addUser(userInput: AddUserInputDto!): UserOutputDto!
  googleSignin(idToken: String!): GoogleSigninResponse!
  completeProfile(updateProfileInput: UpdateProfileInputDto!): Boolean!
  updateUser(id: String!, updateUserInput: UpdateUserInput!): UserOutputDto!
  removeUser(id: String!): Boolean!
  createTeam(input: CreateTeamInput!): Team!
  updateTeam(id: ID!, input: UpdateTeamInput!): Team!
  deleteTeam(id: ID!): Boolean!
  joinTeam(code: String!): Team!
  leaveTeam(teamId: ID!): Boolean!
  removeTeamMember(teamId: ID!, userId: ID!): Boolean!
  updateMemberRole(teamId: ID!, userId: ID!, role: String!): TeamMember!
  createMatch(input: CreateMatchInput!): TeamMatch!

  """Get existing match for today or create one if none exists"""
  getOrCreateTodayMatch(teamId: ID!): TeamMatch!
  updateMatch(id: ID!, input: UpdateMatchInput!): TeamMatch!
  deleteMatch(id: ID!): Boolean!
  uploadPhoto(matchId: ID!, file: Upload!, category: String, isHighlight: Boolean = false): Media!
  uploadVideo(matchId: ID!, file: Upload!, category: String, isHighlight: Boolean = false): Media!
  uploadMedia(input: UploadMediaInput!): Media!
  batchUploadMedia(inputs: [UploadMediaInput!]!): [Media!]!
  updateMedia(id: ID!, input: UpdateMediaInput!): Media!
  deleteMedia(id: ID!): Boolean!
  toggleHighlight(mediaId: ID!): Media!
  tagUsersInMedia(mediaId: ID!, userIds: [ID!]!): Boolean!
  selfTagMedia(mediaId: ID!): Boolean!
  removeMediaTag(mediaId: ID!, userId: ID!): Boolean!
  createPendingTag(input: CreatePendingTagInput!): PendingTag!
  cancelPendingTag(id: ID!): Boolean!
  claimPendingTag(inviteCode: String!): PendingTag!

  """Claim all pending tags by phone number (called after registration)"""
  claimPendingTagsByPhone(phone: String!): Boolean!
  markNotificationAsRead(notificationId: ID!): Notification
  markAllNotificationsAsRead: Int!
  createBrand(input: CreateBrandInput!): Brand!
  updateBrand(input: UpdateBrandInput!): Brand!
  setActiveBrand(brandId: ID!): Brand!
  deleteBrand(id: ID!): Boolean!
  createTemplate(input: CreateTemplateInput!): Template!
  updateTemplate(input: UpdateTemplateInput!): Template!
  duplicateTemplate(templateId: ID!, newName: String): Template!
  deleteTemplate(id: ID!): Boolean!
  saveAsMyTemplate(designId: ID!, thumbnailUrl: String!): Template!
  publishAsTemplate(designId: ID!, thumbnailUrl: String!): Template!
  unpublishTemplate(templateId: ID!): Template!
  uploadTemplateThumbnail(base64Data: String!, templateId: ID!, format: String = "png"): ThumbnailUploadResult!
  uploadTemplateImage(base64Data: String!, templateId: ID!, imageId: String!, format: String = "jpg"): ThumbnailUploadResult!
  deleteTemplateImage(path: String!, templateId: ID!): Boolean!
  deleteTemplateImages(paths: [String!]!, templateId: ID!): Int!
  claimContent(contentId: String!, brandId: String!): ContentSuggestion!
  unclaimContent(contentId: String!, brandId: String!): ContentSuggestion!
  markContentDone(contentId: String!, brandId: String!): ContentSuggestion!
  markContentSeen(contentId: String!, brandId: String!): ContentSuggestion!
  inviteToBrand(input: InviteToBrandInput!): BrandInvitationResult!
  joinBrand(input: JoinBrandInput!): Brand!
  updateBrandMemberRole(input: UpdateBrandMemberRoleInput!): BrandMemberWithUser!
  removeBrandMember(brandId: ID!, userId: ID!): Boolean!
  leaveBrand(brandId: ID!): Boolean!
  revokeBrandInvitation(invitationId: ID!): Boolean!
  generatePost(input: GeneratePostInput!): Post!
  claimPost(id: ID!): Post!
  releasePost(id: ID!): Post!
  updatePostContent(input: UpdatePostContentInput!): Post!
  markPostReady(id: ID!): Post!
  markPostDownloaded(id: ID!): Post!
  markPostPublished(id: ID!): Post!
  rejectPost(input: RejectPostInput!): Post!
  submitPostFeedback(input: SubmitFeedbackInput!): Post!
  savePostTemplate(input: SavePostTemplateInput!): Post!
  generateViralContent(input: GenerateViralContentInput!): ViralContentResponse!
  createStream(input: CreateStreamInput!): Stream!
  updateStream(id: ID!, input: UpdateStreamInput!): Stream!
  startStream(id: ID!): Stream!
  endStream(id: ID!): Stream!
  updateScore(input: UpdateScoreInput!): Stream!
  deleteStream(id: ID!): Boolean!
  joinStream(streamId: ID!): Stream!
  leaveStream(streamId: ID!): Stream!
  regenerateStreamKey: String!
  sendMessage(input: SendMessageInput!): Message!
  createCheckoutSession: CheckoutSessionOutput!
  cancelSubscription: UserSubscription!

  """Generar frases con IA (requiere autenticación)"""
  generateFrases(input: GenerateFraseInput!): GenerateResponse!

  """Guardar una frase generada"""
  saveFrase(input: SaveFraseInput!): Frase!

  """Dar like a una frase"""
  toggleLike(id: ID!): Frase!

  """Cambiar visibilidad pública/privada de una frase"""
  togglePublic(id: ID!): Frase!

  """Eliminar una frase"""
  deleteFrase(id: ID!): Boolean!

  """Actualizar URL de imagen exportada"""
  updateExportedImage(id: ID!, imageUrl: String!): Frase!

  """Analyze ONE match for G1H"""
  analyzeSingleG1H(input: AnalyzeG1HInput!): AnalysisResultDto

  """Analyze ALL matches for G1H - batch analysis"""
  analyzeG1H(input: AnalyzeG1HInput!): AnalysisResultDto

  """
  Run the FHG daily pipeline: fetch matches, generate predictions, evaluate value, create selections
  """
  fhgRunDailyPipeline(options: FhgPipelineOptionsInput): DailyPipelineResultDto!

  """Settle pending FHG selections (calculate outcomes and CLV)"""
  fhgSettleSelections: SettlementResultDto!

  """Import/refresh matches from API-Football for all active leagues"""
  fhgRefreshMatches(date: String, daysAhead: Int = 7): RefreshResultDto!

  """Refresh team statistics for FHG analysis"""
  fhgRefreshTeamStats(leagueCode: String): RefreshResultDto!

  """Refresh odds for FHG matches"""
  fhgRefreshOdds(matchId: ID): RefreshResultDto!

  """Full data refresh: matches + odds for all active leagues"""
  fhgFullRefresh(date: String, daysAhead: Int = 7): RefreshResultDto!
}

input SigninInputDto {
  email: String!
  password: String!
}

input SignupInputDto {
  email: String!
  password: String!
}

input ConfirmSignupInputDto {
  email: String!
  verificationCode: String!
  password: String!
  phone: Float!
  userName: String!
  birthday: DateTime!
}

input ConfirmPasswordInputDto {
  email: String!
  newPassword: String!
  verificationCode: String!
}

input AddUserInputDto {
  email: String!
  password: String!
  phone: Float!
  role: UserRole
  name: String
}

input UpdateProfileInputDto {
  userName: String!
  birthday: DateTime!
  phone: String
  password: String!
  idToken: String!
}

input UpdateUserInput {
  roles: [UserRole!]
  userName: String
  name: String
  avatarUrl: String
}

input CreateTeamInput {
  name: String!
  color: TeamColor!
}

input UpdateTeamInput {
  name: String
  color: TeamColor
}

input CreateMatchInput {
  teamId: ID!
  date: DateTime!
  opponent: String
  location: String
}

input UpdateMatchInput {
  date: DateTime
  opponent: String
  location: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

input UploadMediaInput {
  matchId: ID!
  type: MediaType!
  url: String!
  thumbnailUrl: String
  category: MediaCategory
  isHighlight: Boolean = false
  duration: Float
}

input UpdateMediaInput {
  thumbnailUrl: String
  category: MediaCategory
  isHighlight: Boolean
  duration: Float
}

input CreatePendingTagInput {
  mediaId: ID!
  name: String!
  phone: String
}

input CreateBrandInput {
  fanPageId: String!
  fanPageName: String!
  tokens: ThemeTokensInput!
  watermark: WatermarkConfigInput!
  contentPreferences: ContentPreferencesInput
  isActive: Boolean = false
}

input ThemeTokensInput {
  primaryColor: String!
  secondaryColor: String!
  accentColor: String!
  backgroundColor: String!
  textColor: String!
  logo: String!
  fontPrimary: String!
  fontSecondary: String!
  fanPageName: String!
}

input WatermarkConfigInput {
  style: String!
  position: String!
  customText: String
  showBackground: Boolean!
  backgroundColor: String
  size: String!
}

input ContentPreferencesInput {
  pageType: String
  gender: String
  teamId: String
  leagueId: String
  additionalTeams: [String!]
  contentTypes: [String!]!
  publishLanguage: String!
  sourceLanguages: [String!]!
  notifyBreaking: Boolean!
  notifyMatchday: Boolean!
}

input UpdateBrandInput {
  id: ID!
  fanPageName: String
  tokens: ThemeTokensInput
  watermark: WatermarkConfigInput
  contentPreferences: ContentPreferencesInput
  isActive: Boolean
}

input CreateTemplateInput {
  brandId: ID
  name: String!
  description: String
  category: String!
  thumbnail: String
  width: Int!
  height: Int!
  backgroundColor: String!
  templateData: JSON!
  tags: [String!]
  isPublished: Boolean = false
  presetId: String
  type: String = "template"
}

input UpdateTemplateInput {
  id: ID!
  name: String
  description: String
  category: String
  thumbnail: String
  width: Int
  height: Int
  backgroundColor: String
  templateData: JSON
  tags: [String!]
  isPublished: Boolean
}

input InviteToBrandInput {
  brandId: ID!
  role: BrandMemberRole!
  email: String
}

input JoinBrandInput {
  code: String!
}

input UpdateBrandMemberRoleInput {
  brandId: ID!
  userId: ID!
  role: BrandMemberRole!
}

input GeneratePostInput {
  suggestionId: String!
  brandId: ID!
}

input UpdatePostContentInput {
  postId: ID!
  finalText: String!
}

input RejectPostInput {
  postId: ID!
  reason: String
}

input SubmitFeedbackInput {
  postId: ID!
  rating: Int!
  notes: String
}

input SavePostTemplateInput {
  postId: ID!
  templateData: JSON!
}

input GenerateViralContentInput {
  eventType: MatchEventType!
  minute: Int!
  playerName: String
  assistName: String
  detail: String
  homeTeam: String!
  awayTeam: String!
  homeScore: Int!
  awayScore: Int!
  competition: String!
  round: String
  venue: String
  isHome: Boolean!
  ourTeam: String!
  possession: PossessionInput
  shots: ShotsInput
  shotsOnTarget: ShotsInput
}

enum MatchEventType {
  GOAL
  CARD
  SUBSTITUTION
  VAR
  HALFTIME
  FULLTIME
  KICKOFF
}

input PossessionInput {
  home: Int!
  away: Int!
}

input ShotsInput {
  home: Int!
  away: Int!
}

input CreateStreamInput {
  title: String!
  description: String
  sport: StreamSport = SOCCER
  homeTeam: String
  awayTeam: String
  thumbnailUrl: String
  scheduledAt: DateTime
}

input UpdateStreamInput {
  title: String
  description: String
  sport: StreamSport
  homeTeam: String
  awayTeam: String
  thumbnailUrl: String
  scheduledAt: DateTime
}

input UpdateScoreInput {
  streamId: ID!
  homeScore: Int!
  awayScore: Int!
}

input SendMessageInput {
  streamId: ID!
  content: String!
  type: MessageType = TEXT
}

input GenerateFraseInput {
  categoria: FraseCategory!
  tono: FraseTone
  equipo: String
  count: Int! = 3
}

input SaveFraseInput {
  texto: String!
  autor: String
  categoria: FraseCategory!
  tono: FraseTone
  equipo: String
  emoji: String
  tag: String
  exportedImageUrl: String
}

input AnalyzeG1HInput {
  matches: [G1HMatchInput!]!
  leagueName: String!
}

input G1HMatchInput {
  home: String!
  away: String!
  date: String!
  time: String!
  comp: String!
}

input FhgPipelineOptionsInput {
  date: String
  leagueCode: String
  dryRun: Boolean
  forceRegenerate: Boolean
}

type Subscription {
  viewerCountUpdated(streamId: ID!): ViewerCountUpdate!
  scoreUpdated(streamId: ID!): ScoreUpdate!
  streamStatusChanged(streamId: ID!): StreamStatusUpdate!
  messageAdded(streamId: ID!): Message!
}